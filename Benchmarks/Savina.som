class Savina usingPlatform: platform andHarness: harness = Value (
| private Benchmark = harness Benchmark.
  private actors    = platform actors.
  private Array     = platform kernel Array.
  private Vector    = platform kernel Vector.
  private Dictionary= platform collections Dictionary.
  private system    = platform system.
|
)(
  (* A simple PRNG, to be as portable as possible. *)
  public class Random new: seed = (
    | private seed ::= seed. |
  ) (
    public next = (
      seed := ((seed * 1309) + 13849) & 65535.
      ^ seed
    )
  ) : (
    public new = (
      ^ new: 74755
    )
  )

  (* === Savina Microbenchmarks === *)
  
  public class PingPong new: numPings = Benchmark <: Value (
  | private NumPings     = numPings.
  |
  )(
    class Ping new: cnt with: pong = (
      | private pingsLeft ::= cnt.
        private pong = pong.
      |
    ) (
      public start = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public ping = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public pong: sender = (
        pingsLeft > 0
          ifTrue:  [ self <-: ping ]
          ifFalse: [ pong <-: stop ].
      )
    )
  
    class Pong new: completionRes = (
    | private pongCount ::= 0.
      private completionRes = completionRes.
    |
    ) (
      public ping: sender = (
        sender <-: pong: self.
        pongCount := pongCount + 1.
      )
    
      public stop = (
        completionRes resolve: pongCount
      )
    )
    
    public benchmark = (
      | ping pong completionPP |
      completionPP := actors createPromisePair.
      pong := (actors createActorFromValue: Pong) <-: new: completionPP resolver.
      ping := (actors createActorFromValue: Ping) <-: new: NumPings with: pong.
      ping <-: start.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = NumPings
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )

  public class Counting new: limit = Benchmark <: Value (
  | private limit = limit. |
  )(
    public class ProducerActor new: counter resolver: completionRes = (
    | private counter = counter.
      private completionRes = completionRes.
    |
    )(
      public increment = (
        1 to: limit do: [:i |
          counter <-: increment ].
        
        counter <-: requestCount: self.
      )
      
      public count: cnt = (
        completionRes resolve: cnt = limit
      )
    )
    
    public class CountingActor = (
    | private count ::= 0. |
    ) (
      public increment = (
        count := count + 1.
      )
      
      public requestCount: requester = (
        requester <-: count: count
      )
    )
  
    public benchmark = (
      | counter producer completionPP |
      completionPP := actors createPromisePair.
      counter  := (actors createActorFromValue: CountingActor) <-: new.
      producer := (actors createActorFromValue: ProducerActor) <-: new: counter resolver: completionPP resolver.
      producer <-: increment.

      ^ completionPP promise
    )
    
    public verifyResult: isCorrect = (
      ^ isCorrect
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 10000 )
  )

  public class ForkJoinThroughput new: numActors  totalMessages: numMessages = Benchmark <: Value (
  | private numActors    = numActors.
    private numMessages  = numMessages.
  |
  )(
    class ThroughputActor new: completionResolver = (
    | private messagesProcessed  ::= 0.
      private completionResolver = completionResolver.
    |
    )(
      private performComputation: theta = (
        | sint res |
        sint := theta sin.
        res := sint * sint.
        
        (* defeat dead code elimination *)
        res <= 0.0 ifTrue: [
          system error: 'Benchmark calculated unrealistic res value ' + res asString ]
      )
     
      public process = (
        messagesProcessed := messagesProcessed + 1.
        self performComputation: 37.2.
        
        messagesProcessed = numMessages ifTrue: [
          completionResolver resolve: messagesProcessed
        ]
      )
    )
  
    public benchmark = (
      | benchActors promiseGroup |
      promiseGroup := nil.
      benchActors := Array new: numActors withAll: [
        | promisePair |
        promisePair := actors createPromisePair.
        promiseGroup
          ifNil:    [ promiseGroup := promisePair promise ]
          ifNotNil: [ promiseGroup := promiseGroup, promisePair promise ].
        (actors createActorFromValue: ThroughputActor) <-: new: promisePair resolver
      ].
      
      numMessages timesRepeat: [
        benchActors do: [:a | a <-: process ] ].
      
      ^ promiseGroup
    )
    
    public verifyResult: result = (
      result do: [:n | n = numMessages ifFalse: [ ^ false ] ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
         totalMessages: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '100:1000' )
  )

  public class ForkJoinActorCreation new: numActors = Benchmark <: Value (
  | private numActors = numActors. |
  )(
    class ForkJoinActor new: completionResolver = (
      completionResolver resolve: (performComputation: 37.2)
    )()
    
    private performComputation: theta = (
      | sint res |
      sint := theta sin.
      res := sint * sint.

      res <= 0.0 ifTrue: [
        system error: 'Benchmark calculated unrealistic res value ' + res asString ].
      ^ res
    )
  
    public benchmark = (
      | promiseGroup |
      promiseGroup := nil.
      
      numActors timesRepeat: [
        | promisePair |
        promisePair := actors createPromisePair.
        promiseGroup
          ifNil:    [ promiseGroup := promisePair promise ]
          ifNotNil: [ promiseGroup := promiseGroup, promisePair promise ].
        (actors createActorFromValue: ForkJoinActor) <-: new: promisePair resolver.
      ].
      ^ promiseGroup
    )
    
    public verifyResult: resultVector = (
      | expResult |
      expResult := performComputation: 37.2.
      resultVector do: [:r | r = expResult ifFalse: [ ^ false ] ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )
  
  public class ThreadRing new: numActors numPings: numPings = Benchmark <: Value(
  | private numActors = numActors.
    private numPings  = numPings.
  |
  )(
    class ThreadRingActor new: id resolver: completionRes = (
    | private id = id.
      private nextAct ::= nil.
      private completionRes = completionRes.
    |
    )(
      public ping: t = (
        t > 0 ifTrue: [
          nextAct <-: ping: t - 1
        ] ifFalse: [
          nextAct <-: exit: numActors
        ]
      )
      
      public exit: t = (
        t > 0 ifTrue: [
          nextAct <-: exit: t - 1
        ] ifFalse: [
          completionRes resolve: id.
        ]
      )
      
      public nextActor: actor = (
        nextAct := actor
      )
    )
    
    public benchmark = (
      | threadActors completionPP |
      completionPP := actors createPromisePair.
      threadActors := Array new: numActors.
      1 to: numActors do: [:i |
        | threadActor |
        threadActor := (actors createActorFromValue: ThreadRingActor) <-: new: i resolver: completionPP resolver.
        threadActors at: i put: threadActor.
      ].
      
      1 to: numActors do: [:i |
        | nextActor |
        nextActor := threadActors at: (i % numActors) + 1.
        (threadActors at: i) <-: nextActor: nextActor.
      ].
      
      (threadActors at: 1) <-: ping: numPings.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = 2
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
        numPings: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '30:300' )
  )
  
  public class Chameneos meetings: numMeetings chameneos: numChameneos = Benchmark <: Value (
  | private numMeetings  = numMeetings.
    private numChameneos = numChameneos.
    
    private red    = Red    new.
    private yellow = Yellow new.
    private blue   = Blue   new.
    private faded  = Faded  new.
  |
  )(
    class Red = Value ()(
      public complement: other = ( ^ other redComplement )
      public redComplement     = ( ^ red    )
      public yellowComplement  = ( ^ blue   )
      public blueComplement    = ( ^ yellow )
    )
    class Yellow = Value ()(
      public complement: other = ( ^ other yellowComplement )
      public redComplement     = ( ^ blue   )
      public yellowComplement  = ( ^ yellow )
      public blueComplement    = ( ^ red    )
    )
    class Blue = Value ()(
      public complement: other = ( ^ other blueComplement )
      public redComplement     = ( ^ yellow )
      public yellowComplement  = ( ^ red    )
      public blueComplement    = ( ^ blue   )
    )
    class Faded = Value ()(
      public complement: other = ( ^ faded )
    )
  
    class ChameneosMallActor new: completionRes = (
    | private waitingChameneo ::= nil.
      private sumMeetings     ::= 0.
      private numFaded        ::= 0.
      private n               ::= numMeetings.
      private completionRes   = completionRes.
    |
      start.
    )(
      private color: anInt = (
        | colorIdx |
        colorIdx := anInt % 3.
        colorIdx = 0 ifTrue: [ ^ red    ].
        colorIdx = 1 ifTrue: [ ^ yellow ].
        colorIdx = 2 ifTrue: [ ^ blue   ].
      )

      private start = (
        0 to: numChameneos - 1 do: [:i |
          | color |
          color := color: i.
          (actors createActorFromValue: ChameneosChameneoActor) <-: new: self color: color
        ]
      )

      public meetingCount: count = (
        numFaded := numFaded + 1.
        sumMeetings := sumMeetings + count.
        numFaded = numChameneos ifTrue: [ completionRes resolve: sumMeetings ]
      )
      
      public meet: sender color: color = (
        n > 0 ifTrue: [
          waitingChameneo
            ifNil: [ waitingChameneo := sender ]
            ifNotNil: [
              n := n - 1.
              waitingChameneo <-: meet: sender color: color.
              waitingChameneo := nil.
            ]
        ] ifFalse: [
          sender <-: exit: self
        ]
      )
    )
    
    class ChameneosChameneoActor new: mall color: color = (
    | private mall       = mall.
      private color    ::= color.
      private meetings ::= 0.
    |
      start.
    )(
      private start = (
        mall <-: meet: self color: color.
      )

      public meet: sender color: otherColor = (
        | complement |
        complement := color complement: otherColor.
        meetings := meetings + 1.
        sender <-: change: color.
        mall   <-: meet: self color: color.
      )
      
      public change: newColor = (
        color := newColor.
        meetings := meetings + 1.
        mall <-: meet: self color: newColor.
      )
      
      public exit: sender = (
        color := faded.
        sender <-: meetingCount: meetings
      )
    )
    
    public benchmark = (
      | mallActor completionPP |
      completionPP := actors createPromisePair.
      mallActor := (actors createActorFromValue: ChameneosMallActor) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: sumMeetings = (
      ^ sumMeetings = (2 * numMeetings)
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self meetings: (problem at: 1) asInteger
            chameneos: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '100:200000' )
  )
  
  public class Big = Benchmark ()( todo = () )
  (* === Savina Concurrency Benchmarks === *)

  public class ConcurrentDictionary numEntities: numEntities numMessages: numMessages writePercentage: writePercentage = Benchmark <: Value (
  | private numMessages = numMessages.
    private numEntities = numEntities.
    private writePercentage = writePercentage.
  |
  )(
    class Master new: completionRes = (
    | private workers    = Array new: numEntities.
      private dictionary = (actors createActorFromValue: DictionaryActor) <-: new: completionRes.
      private numWorkersTerminated ::= 0.
    |
      start.
    )(
      private start = (
        workers doIndexes: [:i |
          | worker |
          worker := (actors createActorFromValue: Worker) <-: new: self dict: dictionary id: i.
          workers at: i put: worker.
          worker <-: doWork.
        ]
      )
      
      public endWork = (
        numWorkersTerminated := numWorkersTerminated + 1.
        numWorkersTerminated = numEntities ifTrue: [
          dictionary <-: endWork.
        ]
      )
    )
    
    class Worker new: master dict: dictionary id: id = (
    | private messageCount ::= 0.
      private random = Random new: id + numMessages + writePercentage.
      private master = master.
      private dictionary = dictionary.
    |
    )(
      public doWork = (
        messageCount := messageCount + 1.
        messageCount <= numMessages
          ifTrue: [
            | rnd |
            rnd := random next % 100.
            rnd < writePercentage
              ifTrue:  [ dictionary <-: write: self key: random next value: random next ]
              ifFalse: [ dictionary <-: read: self key: random next ] ]
          ifFalse: [ master <-: endWork ].
      )
      
      public result: value = (
        self doWork
      )
    )
    
    class DictionaryActor new: completionRes = (
    | private dataMap = self createDataMap: 524287 / 1024. (* Integer.MAX_VALUE / 4_096 TODO: this is not the same constant as originally! *)
      private completionRes = completionRes.
    |
    )(
      private createDataMap: dataLimit = (
        | dict |
        dict := Dictionary new.
        1 to: dataLimit do: [:i |
          dict at: i put: i
        ].
        ^ dict
      )
      
      public write: sender key: key value: val = (
        dataMap at: key put: val.
        sender <-: result: val
      )
      
      public read: sender key: key = (
        sender <-: result: (dataMap at: key)
      )
      
      public endWork = (
        completionRes resolve: dataMap size
      )
    )
  
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numEntities =  20 and: [numMessages = 100  and: [writePercentage = 20]]) ifTrue: [ ^ result =  904 ].
      (numEntities =  20 and: [numMessages = 100  and: [writePercentage = 50]]) ifTrue: [ ^ result = 1560 ].
      (numEntities =  20 and: [numMessages = 1000 and: [writePercentage = 20]]) ifTrue: [ ^ result = 3671 ].
      (numEntities = 100 and: [numMessages = 100  and: [writePercentage = 50]]) ifTrue: [ ^ result = 4759 ].
      (numEntities =  10 and: [numMessages = 1000 and: [writePercentage = 50]]) ifTrue: [ ^ result = 4816 ].
      (numEntities =  20 and: [numMessages = 1000 and: [writePercentage = 50]]) ifTrue: [ ^ result = 7265 ].

      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numEntities: (problem at: 1) asInteger
             numMessages: (problem at: 2) asInteger
         writePercentage: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:100:50'
    )
  )

  public class ConcurrentSortedLinkedList numWorkers: w numMessagesPerWorker: mw writePercentage: wp sizePercentage: sp = Benchmark <: Value (
  | private numWorkers           = w.
    private numMessagesPerWorker = mw.
    private writePercentage      = wp.
    private sizePercentage       = sp.
  |)(
    class Master new: completionRes = (
    | private workers    = Array new: numWorkers.
      private sortedList = (actors createActorFromValue: SortedList) <-: new: completionRes.
      private numWorkersTerminated ::= 0.
    |
      workers doIndexes: [:i |
        workers at: i put: ((actors createActorFromValue: Worker) <-: new: self sortedList: sortedList id: i).
        (workers at: i) <-: doWork.
      ]
    )(
      public endWork = (
        numWorkersTerminated := numWorkersTerminated + 1.
        numWorkersTerminated = numWorkers ifTrue: [
          sortedList <-: endWork
        ]
      )
    )
    
    class Worker new: master sortedList: sortedList id: id = (
    | private master = master.
      private sortedList = sortedList.
      private messageCount ::= 0.
      private random = Random new: id + numMessagesPerWorker + writePercentage + sizePercentage.
    |)(
      public endWork = (
        messageCount := messageCount + 1.
        master <-: endWork.
      )

      public doWork = (
        messageCount := messageCount + 1.
        messageCount <= numMessagesPerWorker
          ifTrue: [
            | anInt |
            anInt := random next % 100.
            anInt < sizePercentage
              ifTrue: [ sortedList <-: size: self.
                        ^ self ].
            anInt < (sizePercentage + writePercentage)
              ifTrue: [ sortedList <-: write: random next sender: self.
                        ^ self].
            sortedList <-: contains: random next sender: self ]
          ifFalse: [
            master <-: endWork
          ]
      )
      
      public result: val = (
        self doWork
      )
    )
    
    class SortedList new: completionRes = (
    | private completionRes = completionRes.
      private dataList = SortedLinkedList new.
    |)(
      public write: anInt sender: sender = (
        dataList add: anInt.
        sender <-: result: anInt
      )
      
      public contains: anInt sender: sender = (
        | result |
        result := dataList contains: anInt.
        sender <-: result: result.
      )
      
      public size: sender = (
        sender <-: result: dataList size
      )
      
      public endWork = (
        completionRes resolve: dataList size
      )
    )
    
    class SortedLinkedList = (
    | private head ::= nil.
      private iterator ::= nil.
    |)(
      class Node new: i = (
      | public item ::= i.
        public next ::= nil.
      |)()
      
      public isEmpty = ( ^ head isNil )
      
      public add: item = (
        | newNode after before |
        newNode := Node new: item.
        head ifNil: [
          head := newNode.
          ^ self ].

        item < head item ifTrue: [
          newNode next: head.
          head := newNode.
          ^ self ].
        
        after  := head next.
        before := head.
        
        [ after notNil and: [ item >= after item] ] whileTrue: [
          before := after.
          after  := after next.
        ].
        
        newNode next: before next.
        before next: newNode.
      )
      
      public contains: item = (
        | n |
        n := head.
        [ n notNil ] whileTrue: [
          item = n item ifTrue: [ ^ true ].
          n := n next.
        ].
        ^ false
      )
      
      public size = (
        | r n |
        r := 0.
        n := head.
        [ n notNil ] whileTrue: [
          r := r + 1.
          n := n next
        ].
        ^ r
      )
    )
  
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numWorkers = 10 and: [numMessagesPerWorker =   20 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =   18 ].
      (numWorkers = 10 and: [numMessagesPerWorker =  100 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  106 ].
      (numWorkers = 10 and: [numMessagesPerWorker =  300 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  292 ].
      (numWorkers = 10 and: [numMessagesPerWorker =  500 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  476 ].
      (numWorkers = 10 and: [numMessagesPerWorker = 1000 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  992 ].
      (numWorkers = 10 and: [numMessagesPerWorker = 1500 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result = 1496 ].
      (numWorkers = 20 and: [numMessagesPerWorker = 1000 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result = 1959 ].
      (numWorkers = 20 and: [numMessagesPerWorker = 2000 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result = 3956 ].
      
      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self        numWorkers: (problem at: 1) asInteger
          numMessagesPerWorker: (problem at: 2) asInteger
               writePercentage: (problem at: 3) asInteger
                sizePercentage: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '20:8000:10:1'
    )
  )

  public class ProducerConsumerBoundedBuffer bufferSize: bs numProducers: np numConsumers: nc numItemsPerProducer: ni = Benchmark <: Value (
  | private bufferSize   = bs.
    private numProducers = np.
    private numConsumers = nc.
    private numItemsPerProducer = ni.
    private prodCost     = 25.
    private consCost     = 25.
  |)(
    class Data new: datum from: sender = Value (
    | public datum  = datum.
      public sender = sender.|)()
    
    class ManagerActor new: completionRes = (
    | private adjustedBufferSize = bufferSize - numProducers.
      private availableProducers = Vector new.
      private availableConsumers = Vector new.
      private pendingData        = Vector new.
      private numTerminatedProducers ::= 0.
      private producers          = Array new: numProducers.
      private consumers          = Array new: numConsumers.
      private completionRes      = completionRes.
      private dataSum ::= 0.0.
    |
      producers doIndexes: [:i |
        | producer |
        producer := (actors createActorFromValue: ProducerActor) <-: new: i manager: self.
        producers at: i put: producer.
        producer <-: produceData.
      ].
      consumers doIndexes: [:i |
        | consumer |
        consumer := (actors createActorFromValue: ConsumerActor) <-: new: i manager: self.
        consumers at: i put: consumer.
        availableConsumers append: consumer.
      ]
    )(
      public data: datum from: producer = (
        dataSum := dataSum + datum.
        availableConsumers isEmpty
          ifTrue:  [ pendingData append: (Data new: datum from: producer) ]
          ifFalse: [ availableConsumers removeFirst <-: data: datum from: producer ].
        
        pendingData size >= adjustedBufferSize
          ifTrue:  [ availableProducers append: producer ]
          ifFalse: [ producer <-: produceData ]
      )
      
      public consume: consumer = (
        pendingData isEmpty
          ifTrue: [
            availableConsumers append: consumer.
            tryExit ]
          ifFalse: [
            | data |
            data := pendingData removeFirst.
            consumer <-: data: data datum from: data sender.
            availableProducers isEmpty ifFalse: [
              availableProducers removeFirst <-: produceData ] ].
      )
      
      public producerExit = (
        numTerminatedProducers := numTerminatedProducers + 1.
        tryExit
      )
      
      private tryExit = (
        (numTerminatedProducers = numProducers and: [availableConsumers size = numConsumers])
          ifTrue: [
            consumers do: [:c | c <-: exit ].
            completionRes resolve: dataSum ].
      )
    )
    
    class ProducerActor new: id manager: manager = (
    | private prodItem ::= 0.0.
      private itemsProduced ::= 0.
      private manager = manager.
    |)(
      private prodData = (
        prodItem := processItem: prodItem cost: prodCost.
        manager <-: data: prodItem from: self.
        itemsProduced := itemsProduced + 1.
      )
      
      public produceData = (
        itemsProduced < numItemsPerProducer
          ifTrue:  [ self prodData ]
          ifFalse: [ manager <-: producerExit ]
      )
    )
    
    class ConsumerActor new: id manager: manager = (
    | private consItem ::= 0.0.
      private manager = manager.
    |)(
      private consumeDataItem: dataToConsume = (
        consItem := processItem: consItem + dataToConsume cost: consCost.
      )
      
      public data: datum from: sender = (
        consumeDataItem: datum.
        manager <-: consume: self
      )
      
      public exit = ()
    )
    
    private processItem: curTerm cost: cost = (
      | res random |
      res    := curTerm.
      random := Random new: cost.
      
      cost > 0
        ifTrue: [
          cost timesRepeat: [
            100 timesRepeat: [
              res := res + (random next abs + 0.01) log ] ] ]
        ifFalse: [
          res := res + (random next abs + 0.01) log ].
      
      ^ res
    )
  
    public benchmark = (
      | manager completionPP |
      completionPP := actors createPromisePair.
      manager := (actors createActorFromValue: ManagerActor) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (bufferSize = 40 and: [numProducers = 10 and: [numConsumers = 10 and: [numItemsPerProducer =  60]]]) ifTrue: [^ result round =  461187197].
      (bufferSize = 40 and: [numProducers = 10 and: [numConsumers = 10 and: [numItemsPerProducer =  80]]]) ifTrue: [^ result round =  816528152].
      (bufferSize = 40 and: [numProducers = 20 and: [numConsumers = 20 and: [numItemsPerProducer =  80]]]) ifTrue: [^ result round = 1633056304].
      (bufferSize = 50 and: [numProducers = 20 and: [numConsumers = 20 and: [numItemsPerProducer = 100]]]) ifTrue: [^ result round = 2545350104].
      (bufferSize = 50 and: [numProducers = 40 and: [numConsumers = 40 and: [numItemsPerProducer = 100]]]) ifTrue: [^ result round = 5090700207].
      (bufferSize = 40 and: [numProducers = 10 and: [numConsumers = 10 and: [numItemsPerProducer = 600]]]) ifTrue: [^ result round = 45438279572].
      
       
      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      
      ^ self bufferSize: (problem at: 1) asInteger
           numProducers: (problem at: 2) asInteger
           numConsumers: (problem at: 3) asInteger
    numItemsPerProducer: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '50:40:40:1000'
    )
  )

  public class Philosophers = Benchmark ()( todo = () )
  public class SleepingBarber = Benchmark ()( todo = ( USE_MATH_RANDOM_WHICH_SEQUENTIALIZES ) )
  public class CigaretteSmokers = Benchmark ()( todo = ( USE_MATH_RANDOM_WHICH_SEQUENTIALIZES ) )
  public class LogisticsMapSeries = Benchmark ()( todo = () )
  public class BankTransaction = Benchmark ()( todo = () )
  
  (* === Savina Parallelism Benchmarks === *)
  
  public class RadixSort numValues: numValues maxValue: maxValue seed: seed = Benchmark <: Value (
  | private numValues = numValues. 
    private maxValue  = maxValue.  (* Needs to be a power of 2, I think *)
    private seed      = seed.      (* Should probably be a prime number *)
  |
  )(
    class IntSourceActor = (
    | private random = Random new: seed. |
    ) (
      public next: actor = (
        1 to: numValues do: [:i |
          | candidate |
          candidate := (random next % maxValue) abs.
          actor <-: value: candidate.
        ]
      )
    )
  
    class SortActor new: radix next: nextActor = (
    | private radix     = radix.
      private next      = nextActor.
      
      private orderingArray = Array new: numValues withAll: 0.
      private valuesSoFar ::= 0.
      private j           ::= 1.
    |
    )(
      public value: current = (
        valuesSoFar := valuesSoFar + 1.
        
        (current & radix) = 0
          ifTrue:  [
           next <-: value: current ]
          ifFalse: [
            orderingArray at: j put: current.
            j := j + 1
          ].
        
        valuesSoFar = numValues ifTrue: [
          1 to: j - 1 do: [:i |
            next <-: value: (orderingArray at: i)
          ].
        ]
      )
    )
    
    class ValidationActor new: completionRes = (
    | private sumSoFar    ::=  0.
      private valuesSoFar ::=  0.
      private prevValue   ::=  0.
      private errorValue  ::= -1.
      private errorIdx    ::= -1.
      private completionRes = completionRes.
    |
    )(
      public value: val = (
        valuesSoFar := valuesSoFar + 1.
        
        (val < prevValue and: [errorValue < 0]) ifTrue: [
          errorValue := val.
          errorIdx   := valuesSoFar.
          system error: 'ERROR: Value out of place: ' + errorValue + ' at index ' + errorIdx
        ].
        
        prevValue := val.
        sumSoFar := sumSoFar + prevValue.
        
        valuesSoFar = numValues ifTrue: [
          errorValue >= 0
            ifTrue:  [ system error: 'Value out of place: ' + errorValue + ' at index ' + errorIdx ].
          completionRes resolve: sumSoFar
        ]
      )
    )
  
    public benchmark = (
      | validationActor sourceActor radix nextActor completionPP |
      completionPP := actors createPromisePair.
      validationActor := (actors createActorFromValue: ValidationActor) <-: new: completionPP resolver.
      sourceActor     := (actors createActorFromValue: IntSourceActor)  <-: new.
      
      radix := maxValue / 2.
      nextActor := validationActor.
      
      [radix > 0] whileTrue: [
        | sortActor |
        sortActor := (actors createActorFromValue: SortActor) <-: new: radix next: nextActor.
        
        radix := radix / 2.
        nextActor := sortActor
      ].
      
      sourceActor <-: next: nextActor.
      
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numValues = 100 and: [maxValue = 256 and: [seed = 74755]]) ifTrue: [
        ^ result = 13606
      ].
      (numValues = 10000 and: [maxValue = 65536 and: [seed = 74755]]) ifTrue: [
        ^ result = 329373752
      ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numValues: (problem at: 1) asInteger
              maxValue: (problem at: 2) asInteger
                  seed: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:256:74755'
    )
  )
  
  public class FilterBank = Benchmark ()( todo = () )
  
  public class Sieve new: limit local: numMaxLocalPrimes = Benchmark <: Value (
  | private limit = limit.
    private numMaxLocalPrimes = numMaxLocalPrimes.
  |
  )(
    class NumberProducerActor = ()(
      public produceNumbersFor: filterActor = (
        | candidate |
        candidate := 3.
        [candidate < limit] whileTrue: [
          filterActor <-: filter: candidate.
          candidate := candidate + 2
        ].
        
        filterActor <-: exit.
      )
    )
    
    class PrimeFilterActor new: id initialPrime: initialPrime resolver: completionRes = (
    | private id = id.
      private initialPrime = initialPrime.
      private nextFilterActor ::= nil.
      private localPrimes = Array new: numMaxLocalPrimes withAll: 0.
      private availableLocalPrimes ::= 1.
      private completionRes = completionRes.
    |
      localPrimes at: 1 put: initialPrime.
    )(
      private handleNewPrim: newPrim = (
        availableLocalPrimes < numMaxLocalPrimes
          ifTrue: [
            (* store locally if there is space *)
            availableLocalPrimes := availableLocalPrimes + 1.
            localPrimes at: availableLocalPrimes put: newPrim ]
          ifFalse: [
            (* create a new actor to store a new prime *)
            nextFilterActor := (actors createActorFromValue: PrimeFilterActor)
              <-: new: id + 1 initialPrime: newPrim resolver: completionRes
          ]
      )
      
      private isLocallyPrime: candidate = (
        1 to: availableLocalPrimes do: [:i |
          | remainder |
          remainder := candidate % (localPrimes at: i).
          remainder = 0 ifTrue: [ ^ false ]
        ].
        ^ true
      )
      
      public filter: candidate = (
        (isLocallyPrime: candidate)
          ifTrue: [
            nextFilterActor
              ifNil:    [handleNewPrim: candidate]
              ifNotNil: [nextFilterActor <-: filter: candidate]
          ]
      )
      public exit = (
        nextFilterActor
          ifNil: [
            | totalPrimes |
            totalPrimes := ((id - 1) * numMaxLocalPrimes) + availableLocalPrimes.
            completionPP resolve: totalPrimes ]
          ifNotNil: [ nextFilterActor <-: exit ]
      )
    )
   
    public benchmark = (
      | producerActor filterActor completionPP |
      completionPP := actors createPromisePair.
      producerActor := (actors createActorFromValue: NumberProducerActor) <-: new.
      filterActor   := (actors createActorFromValue: PrimeFilterActor)    <-: new: 1 initialPrime: 2 resolver: completionPP resolver.

      producerActor <-: produceNumbersFor: filterActor.
      
      ^ completionPP promise
    )
    
    public verifyResult: numberOfPrimes = (
      limit = 100    ifTrue: [ ^ numberOfPrimes =   25 ].
      limit = 1000   ifTrue: [ ^ numberOfPrimes =  168 ].
      limit = 10000  ifTrue: [ ^ numberOfPrimes = 1229 ].
      limit = 100000 ifTrue: [ ^ numberOfPrimes = 9592 ].
      (* otherwise, we don't know. *)
      ^ true 
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
           local: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100000:64'
    )
  )
  
  public class UnbalancedBobwebbedTree = Benchmark ()( todo = () )
  public class OnlineFacilityLocation = Benchmark ()( todo = () )
  public class PrecisePiComputation = Benchmark ()( todo = () )
  public class RecursiveMatricMultiplication = Benchmark ()( todo = () )
  public class Quicksort = Benchmark ()( todo = () )
  public class AllPairsShortestPath = Benchmark ()( todo = ( USES_SHARED_STATE ) )

  public class TrapezoidalApproximation numWorkers: w numPieces: n left: l right: r = Benchmark <: Value (
  | private numWorkers = w.
    private numPieces  = n.
    private left       = l.
    private right      = r.
    private precision  = (r - l) // n.
  |)(
    class Master new: completionRes = (
    | private workers = Array new: numWorkers withAll: ((actors createActorFromValue: Worker) <-: new: self).
      private completionRes    = completionRes.
      private numTermsReceived ::= 0.
      private resultArea       ::= 0.0.
    |)(
      public result: result = (
        numTermsReceived := numTermsReceived + 1.
        resultArea := resultArea + result.
        
        numTermsReceived = numWorkers ifTrue: [
          completionRes resolve: resultArea ]
      )
      
      public work: l and: r and: h = (
        | workerRange |
        workerRange := (r - l) // numWorkers.
        workers doIndexes: [:i |
          | wl wr |
          wl := workerRange * (i - 1) + l.
          wr := wl + workerRange.
          (workers at: i) <-: work: l and: r and: h
        ]
      )
    )
    
    class Worker new: master = (
    | private master = master.
    |)(
      public work: l and: r and: h = (
        | n accumArea |
        n := (r - l) / h.
        accumArea := 0.0.
        
        0 to: n - 1 do: [:i |
          | lx rx ly ry area |
          lx := (i * h) + l.
          rx := lx + h.
          
          ly := fx: lx.
          ry := fx: rx.
          
          area := 0.5 * (ly + ry) * h.
          accumArea := accumArea + area.
        ].
        
        master <-: result: accumArea
      )
      
      private fx: x = (
        | a b c d r |
        a := ((x * x * x) - 1.0) sin.
        b := x + 1.0.
        c := a // b.
        d := ((2.0 * x) exp + 1.0) sqrt.
        r := c * d.
        ^ r
      )
    )
    
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      master <-: work: left and: right and: precision.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numWorkers = 100 and: [numPieces =  2500 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ result = 41.09037687472329 ].
      (numWorkers = 100 and: [numPieces =  5000 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ result = 41.09352993029936 ].
      (numWorkers = 100 and: [numPieces = 10000 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ result = 41.0943179572127  ].
    
      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numWorkers: (problem at: 1) asInteger
              numPieces: (problem at: 2) asInteger
                   left: (problem at: 3) asInteger
                  right: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:10000000:1:5'
    )
  )
  
  
  
  public class SuccessiveOverRelaxation = Benchmark ()( todo = () )
  public class AStarSearch = Benchmark ()( todo = ( USES_A_GLOBAL_RANDOM_INSTANCE ) )
  public class NQueens = Benchmark ()( todo = ( USES_SHARED_STATE ) )
)
