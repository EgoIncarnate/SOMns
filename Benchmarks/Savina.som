class Savina usingPlatform: platform andHarness: harness = (
| private Benchmark = harness Benchmark.
  private actors    = platform actors.
  private Array     = platform kernel Array.
  private system    = platform system.
|
)(
  (* A simple PRNG, to be as portable as possible. *)
  public class Random new: seed = (
    | private seed ::= seed. |
  ) (
    public next = (
      seed := ((seed * 1309) + 13849) & 65535.
      ^ seed
    )
  ) : (
    public new = (
      ^ new: 74755
    )
  )

  public class PingPong new: numPings = Benchmark (
  | private completionPP = actors createPromisePair.
    private NumPings     = numPings.
  |
  )(
    class Ping new: cnt with: pong = (
      | private pingsLeft ::= cnt.
        private pong = pong.
      |
    ) (
      public start = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public ping = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public pong: sender = (
        pingsLeft > 0
          ifTrue:  [ self <-: ping ]
          ifFalse: [ pong <-: stop ].
      )
    )
  
    class Pong = (
      | private pongCount ::= 0. |
    ) (
      public ping: sender = (
        sender <-: pong: self.
        pongCount := pongCount + 1.
      )
    
      public stop = (
        completionPP resolve: pongCount
      )
    )
    
    public benchmark = (
      | ping pong |
      pong := (actors createActorFromValue: Pong) <-: new.
      ping := (actors createActorFromValue: Ping) <-: new: NumPings with: pong.
      ping <-: start.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = NumPings
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )
  
  public class ThreadRing new: numThreads = Benchmark (
  | private N = numThreads.
    private completionPP = actors createPromisePair.
  |
  )(
    class ThreadRingActor new: id numActorsInRing: num = (
    | private id = id.
      private numActorsInRing = num.
      private nextAct ::= nil.
    |
    )(
      public ping: t = (
        t > 0 ifTrue: [
          nextAct <-: ping: t - 1
        ] ifFalse: [
          nextAct <-: exit: numActorsInRing
        ]
      )
      
      public exit: t = (
        t > 0 ifTrue: [
          nextAct <-: exit: t - 1
        ] ifFalse: [
          completionPP resolve: id.
        ]
      )
      
      public nextActor: actor = (
        nextAct := actor
      )
    )
    
    public benchmark = (
      | threadActors |
      threadActors := Array new: N.
      1 to: N do: [:i |
        | threadActor |
        threadActor := (actors createActorFromValue: ThreadRingActor)
                         <-: new: i numActorsInRing: N.
        threadActors at: i put: threadActor.
      ].
      
      1 to: N do: [:i |
        | nextActor |
        nextActor := threadActors at: (i % N) + 1.
        (threadActors at: i) <-: nextActor: nextActor.
      ].
      
      (threadActors at: 1) <-: ping: N.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = 2
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )
  
  public class RadixSort numValues: numValues maxValue: maxValue seed: seed = (
  | private numValues = numValues. 
    private maxValue  = maxValue.  (* Needs to be a power of 2, I think *)
    private seed      = seed.      (* Should probably be a prime number *)
    private completionPP = actors createPromisePair.
  |
  )(
    class IntSourceActor = (
    | private random = Random new: seed. |
    ) (
      public next: actor = (
        1 to: numValues do: [:i |
          | candidate |
          candidate := (random next % maxValue) abs.
          actor <-: value: candidate.
        ]
      )
    )
  
    class SortActor new: radix next: nextActor = (
    | private radix     = radix.
      private next      = nextActor.
      
      private orderingArray = Array new: numValues withAll: 0.
      private valuesSoFar ::= 0.
      private j           ::= 1.
    |
    )(
      public value: current = (
        valuesSoFar := valuesSoFar + 1.
        
        (current & radix) = 0
          ifTrue:  [
           next <-: value: current ]
          ifFalse: [
            orderingArray at: j put: current.
            j := j + 1
          ].
        
        valuesSoFar = numValues ifTrue: [
          1 to: j - 1 do: [:i |
            next <-: value: (orderingArray at: i)
          ].
        ]
      )
    )
    
    class ValidationActor = (
    | private sumSoFar    ::=  0.
      private valuesSoFar ::=  0.
      private prevValue   ::=  0.
      private errorValue  ::= -1.
      private errorIdx    ::= -1.
    |
    )(
      public value: val = (
        valuesSoFar := valuesSoFar + 1.
        
        (val < prevValue and: [errorValue < 0]) ifTrue: [
          errorValue := val.
          errorIdx   := valuesSoFar.
          system error: 'ERROR: Value out of place: ' + errorValue + ' at index ' + errorIdx
        ].
        
        prevValue := val.
        sumSoFar := sumSoFar + prevValue.
        
        valuesSoFar = numValues ifTrue: [
          errorValue >= 0
            ifTrue:  [ system error: 'Value out of place: ' + errorValue + ' at index ' + errorIdx ].
          completionPP resolve: sumSoFar
        ]
      )
    )
  
    public benchmark = (
      | validationActor sourceActor radix nextActor |
      validationActor := (actors createActorFromValue: ValidationActor) <-: new.
      sourceActor     := (actors createActorFromValue: IntSourceActor)  <-: new.
      
      radix := maxValue / 2.
      nextActor := validationActor.
      
      [radix > 0] whileTrue: [
        | sortActor |
        sortActor := (actors createActorFromValue: SortActor) <-: new: radix next: nextActor.
        
        radix := radix / 2.
        nextActor := sortActor
      ].
      
      sourceActor <-: next: nextActor.
      
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numValues = 100 and: [maxValue = 256 and: [seed = 74755]]) ifTrue: [
        ^ result = 13606
      ].
      (numValues = 10000 and: [maxValue = 65536 and: [seed = 74755]]) ifTrue: [
        ^ result = 329373752
      ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numValues: (problem at: 1) asInteger
              maxValue: (problem at: 2) asInteger
                  seed: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:256:74755'
    )
  )
)
